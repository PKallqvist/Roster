<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Fotball Roster </title>
	<link rel="stylesheet" href="style.css">
</head>

<body>
	<div id="workPart">
		<h1>Roster Creator</h1>

		<!-- <label for="matchTitleInput">Match Title:</label>
		<input type="text" id="matchTitleInput" placeholder="Qviding vs MotstÃ¥ndare 25/5-25  " /> -->
		
		<div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap; padding-bottom: 18px;">
			<label for="matchTitleInput">Match Title:</label>
			<input type="text" id="matchTitleInput" placeholder="Qviding vs MotstÃ¥ndare 25/5-25">
		</div>

		<div class="player-container" >

			<table class="preference-table">
				<thead>
					<tr>
					<th>Player</th><th>G</th><th>D</th><th>LW</th><th>RW</th><th>F</th><th></th>
					</tr>
				</thead>
				<tbody id="preferenceGrid"></tbody>
			</table>
		</div>
		<div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap; padding-bottom: 18px;">
			<label for="phasesPerPeriod">Substitution opportunities per period:</label>
			<select id="phasesPerPeriod" onchange="updatePhases()">
				<option value="2">1 (2 phases)</option>
				<option value="3" selected>2 (3 phases)</option>
			</select>
		</div>
		<div>
			<button onclick="runSA()">Generate Schedule</button>
			<button onclick="continueOptimize()">Continue Optimize</button>
			<button onclick="randomizePlayers()">Randomize Players</button>
		</div>


		<div id="output" style="display: none;"></div>
		<div id="score"></div>
		<div id="phaseSchedule"></div>
		<button id="editButton" onclick="toggleEditMode()">Edit Schedule</button>
		
		<!-- <button onclick="toggleView()">Toggle View</button> -->
		<button onclick="window.print()">Print Schedule</button>		
	</div>
	<div class="visual-periods-wrapper" id="print-area-visual" ></div>

	<div id="periodLayout"></div>
		
	<script type="module">
		import { fitness2, 
			setPlayerPreferences,
			setPlayers 
		} from './fitness2.js';
		import {
			getDefenderIcon,
			getLeftWingIcon,
			getRightWingIcon,
			getStrikerIcon,
			getSwapIcon,
			getGlovesIcon,
			getDiamondIcon
		} from './icons.js';	
		

		let players = [];
		let playerPreferences = {};
		const basePositions = ['G', 'D', 'LW', 'RW', 'F'];
		let nrSubs = 0;
		let subs = [];
		let positions = [];

		let phasesPerPeriod = 3;
		let phases = phasesPerPeriod * 3;
		let currentSchedule = null;

		function isSubPosition(pos) {
			return pos.startsWith("SUB");
		}

		function savePlayerNames() {
			document.querySelectorAll('.player-name').forEach(input => {
				const index = input.dataset.index;
				const oldName = players[index];
				const newName = input.value;

				if (oldName !== newName) {
					if (players.includes(newName)) {
						alert("Players must use unique names.");
						input.value = oldName;
						return;
					}
					players[index] = newName;
					playerPreferences[newName] = playerPreferences[oldName] || {};
					delete playerPreferences[oldName];
				} else {
					players[index] = newName;
				}
			});
		}

		document.addEventListener('keydown', function (e) {
			if (!e.target.classList.contains('player-name')) return;

			const inputs = Array.from(document.querySelectorAll('.player-name'));
			const index = inputs.indexOf(e.target);

			if (e.key === 'ArrowDown' && index < inputs.length - 1) {
				e.preventDefault();
				inputs[index + 1].focus();
				inputs[index + 1].select();
			} else if (e.key === 'ArrowUp' && index > 0) {
				e.preventDefault();
				inputs[index - 1].focus();
				inputs[index - 1].select();
			}
		});

		function saveSinglePlayerName(e) {
			const input = e.target;
			const index = input.dataset.index;
			const oldName = players[index];
			const newName = input.value.trim();

			if (!newName || oldName === newName) return;

			if (players.includes(newName)) {
				alert("Players must use unique names.");
				input.value = oldName;
				return;
			}

			players[index] = newName;
			playerPreferences[newName] = playerPreferences[oldName] || {};
			delete playerPreferences[oldName];
			renderPlayerPreferenceTable(); // re-render to update name refs
		}

		function renderPlayerPreferenceTable(focusIndex = null) {
			const tableBody = document.getElementById("preferenceGrid");
			tableBody.innerHTML = '';

			players.forEach((player, index) => {
				const prefs = playerPreferences[player] || {};
				let row = `<tr><td><input value="${player}" class="preference-name-input player-name" data-index="${index}" /></td>`;

				basePositions.forEach(pos => {
					const val = prefs[pos] ?? 0;
					row += `<td><input type="number" class="preference-input" value="${val}" data-player="${player}" data-pos="${pos}" onchange="updatePreference(this)" /></td>`;
				});

				row += `<td><button onclick="removePlayer(${index})">-</button></td></tr>`;
				tableBody.innerHTML += row;
			});

			const totalCols = basePositions.length + 2;
			const addRow = `<tr><td colspan="${totalCols}" style="text-align: center;">
				<button onclick="addPlayer()">+</button>
			</td></tr>`;
			tableBody.innerHTML += addRow;

			setTimeout(() => {
				const inputs = Array.from(document.querySelectorAll('.player-name'));
				inputs.forEach((input, index) => {
					input.addEventListener('blur', e => {
						const newName = input.value.trim();
						const oldName = players[index];

						if (newName && newName !== oldName) {
							if (players.includes(newName)) {
								alert("Players must use unique names.");
								input.value = oldName;
								return;
							}
							players[index] = newName;
							playerPreferences[newName] = playerPreferences[oldName] || {};
							delete playerPreferences[oldName];
							renderPlayerPreferenceTable(focusIndex); // re-render and restore focus
						}
					});

					input.addEventListener('keydown', e => {
						if (e.key === 'Enter') {
							e.preventDefault();
							const targetIndex = index + 1;
							input.blur(); // triggers re-render (if needed)
							setTimeout(() => {
								if (targetIndex >= players.length) {
									addPlayer(); // triggers render and auto-focus
								} else {
									renderPlayerPreferenceTable(targetIndex); // re-render and focus next
								}
							}, 0);
						}
					});
				});

				// Focus a specific input if requested
				if (focusIndex !== null) {
					const target = document.querySelector(`.player-name[data-index="${focusIndex}"]`);
					if (target) {
						target.focus();
						target.select();
					}
				}
			}, 0);
		}





		window.addPlayer = function () {
			savePlayerNames();
			players.push('New Player');
			playerPreferences['New Player'] = {};
			renderPlayerPreferenceTable();

			setTimeout(() => {
				const inputs = document.querySelectorAll('.player-name');
				const newInput = inputs[inputs.length - 1];
				if (newInput) {
					newInput.focus();
					newInput.select();
				}
			}, 0);
		};

		window.removePlayer = function(index) {

			const removed = players.splice(index, 1)[0];
			delete playerPreferences[removed];
			renderPlayerPreferenceTable();
		}


		function collectPlayerPreferences() {
			playerPreferences = {}; // reset
			const inputs = document.querySelectorAll('#preferenceGrid input');
			inputs.forEach(input => {
				const player = input.dataset.player;
				const pos = input.dataset.pos;
				const value = parseInt(input.value, 10) || 0;
				if (!playerPreferences[player]) {
				playerPreferences[player] = {};
				}				
				playerPreferences[player][pos] = value;
			});		
			if (typeof setPlayerPreferences === 'function') {
				setPlayerPreferences(playerPreferences);
			}
		}

		const positionSymbols = {
			// G: 'ðŸ§¤',    // Goalie
			G: 'ðŸ¥…',    // Goalie
			D: 'ðŸ›¡ï¸',    // Defense
			// LW: 'â¬…ï¸',   // Left Wing
			LW: 'ðŸ¡¸',
			// RW: 'âž¡ï¸',   // Right Wing
			RW: 'ðŸ¡º',
			F: 'ðŸŽ¯',    // Forward
			SUB: 'ðŸ”'   // Substitution
		};

	
		const rootStyles = getComputedStyle(document.documentElement);

		const positionColors = {
			G:   rootStyles.getPropertyValue('--color-g').trim(),
			D:   rootStyles.getPropertyValue('--color-d').trim(),
			LW:  rootStyles.getPropertyValue('--color-lw').trim(),
			RW:  rootStyles.getPropertyValue('--color-rw').trim(),
			F:   rootStyles.getPropertyValue('--color-f').trim(),
			SUB: rootStyles.getPropertyValue('--color-sub').trim()
		};
			
		let editMode = false;
		let selectedCell = null;

		window.onload = function () {

			if (players.length === 0) {
				players = ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve', 'Frank', 'Grace'];
				players.forEach(p => playerPreferences[p] = {});
				renderPlayerPreferenceTable();
			}

			window.renderPreferenceGrid = function () {
				const basePositions = ['G', 'D', 'LW', 'RW', 'F'];
				const container = document.getElementById('preferenceGrid');

				if (players.length === 0) {
					window.updatePlayers(); // fallback to textarea
				}

				let html = `<table class="basic-grid"><tr><th>Player</th>`;
				basePositions.forEach(pos => html += `<th>${pos}</th>`);
				html += `</tr>`;

				players.forEach(player => {
					html += `<tr><td>${player}</td>`;
					basePositions.forEach(pos => {
						const value = playerPreferences[player]?.[pos] ?? 0;
						html += `<td><input type="number" value="${value}" min="-100" max="100" style="width: 40px;" data-player="${player}" data-pos="${pos}" onchange="updatePreference(this)" /></td>`;
					});
					html += `</tr>`;
				});

				html += `</table>`;
				container.innerHTML = html;
			};


			window.updatePreference = function(input) {
				const player = input.dataset.player;
				const pos = input.dataset.pos;
				const value = parseInt(input.value, 10) || 0;

				if (!playerPreferences[player]) {
					playerPreferences[player] = {};
				}
				playerPreferences[player][pos] = value;

				if (typeof setPlayerPreferences === 'function') {
					setPlayerPreferences(playerPreferences);
				}
			};


			window.updatePhases = function () {
				phasesPerPeriod = parseInt(document.getElementById("phasesPerPeriod").value, 10);
				phases = phasesPerPeriod * 3;			
			}


			window.updatePlayers = function () {
				savePlayerNames(); // capture edited names

				nrSubs = players.length - 5;
				subs = Array.from({ length: nrSubs }, (_, i) => `SUB${i + 1}`);
				positions = basePositions.concat(subs);

				if (typeof setPlayers === 'function') {
					setPlayers(players);
				}
			};

			function generatePerfectInitialState() {
				const perfectStateIds_7_2 = [
					[1, 6, 5, 2, 4, 7, 3],
					[1, 7, 3, 2, 4, 5, 6],
					[1, 7, 3, 5, 6, 4, 2],
					[2, 3, 4, 5, 6, 7, 1],
					[2, 3, 4, 1, 7, 5, 6],
					[2, 5, 6, 1, 7, 4, 3],
					[3, 5, 6, 4, 2, 7, 1],
					[3, 1, 7, 4, 2, 6, 5],
					[3, 1, 7, 6, 5, 2, 4]
				];
				const perfectStateIds_6_2 = [
					[1, 2, 4, 5, 3, 6],
					[1, 2, 6, 5, 3, 4],
					[1, 4, 6, 5, 3, 2],
					[2, 4, 6, 3, 1, 5],
					[2, 4, 5, 3, 1, 6],
					[2, 6, 5, 4, 1, 3],
					[3, 6, 2, 4, 5, 1],
					[3, 1, 2, 6, 5, 4],
					[3, 1, 2, 6, 4, 5]
				];


				let perfectStateIds = players.length == 7 ? perfectStateIds_7_2 : perfectStateIds_6_2;

				// Map numeric IDs to player names (assuming players[0] = 'Alice' etc.)
				const state = perfectStateIds.map(row => row.map(id => players[id - 1]));

				return state;
			}

			function generateInitialState() {				
				if (phases === 9)
					return generatePerfectInitialState();
				const state = [];
				for (let i = 0; i < phases; i++) {
					const phasePlayers = [...players].sort(() => Math.random() - 0.5);
					state.push(phasePlayers);
				}
				
				return state;
				
				
			}

			function applyGoalieLocks(state) {
				
				for (let phase = 0; phase < state.length; phase++) {
					const periodIndex = Math.floor(phase / phasesPerPeriod);
					const goalie = players[periodIndex % 3]; // Cycle through first 3 goalies
					const filtered = state[phase].filter(p => p !== goalie);
					state[phase] = [goalie, ...filtered];
				}
			}

			
			window.toggleEditMode = function () {
				editMode = !editMode;
				selectedCell = null;

				const btn = document.getElementById("editButton");
				if (btn) {
					btn.classList.toggle("active-button", editMode);
				}
				};

			function fitness(state) {
				return fitness2(state);				
			}

			// Helpers
			function isSubPosition(pos) {
				return pos.startsWith("SUB");
			}

			function isGoalie(player) {
				return player === players[0] || player === players[1] || player === players[2];
			}



			function averageNonGoaliePlaytime() {
				const nonGoalies = players.filter(p => !isGoalie(p));
				return (phases * (positions.length - 3)) / nonGoalies.length; // 3 goalie positions assumed
			}


			function getNeighborSwapPositions(state) {
				const newState = JSON.parse(JSON.stringify(state));
				const positionCount= basePositions.length-1;
				// Pick two positions to swap
				let i = 1 + Math.floor(Math.random() * positionCount);
				let j = 1 + Math.floor(Math.random() * positionCount);

				let p1 = Math.floor(Math.random() * (phases-1));
				let p2 =  p1 + 1 + Math.floor(Math.random() * (phases-p1));
				p1=0;
				p2 = phases;

				for (let phase = p1; phase < p2; phase++) {
					const temp = newState[phase][i];
					newState[phase][i] = newState[phase][j];
					newState[phase][j] = temp;
				}

				return newState;
			}

			function getNeighborEnforce2Phase(state) {
				const newState = JSON.parse(JSON.stringify(state));
				const midPhase = Math.floor(Math.random() * (phases - 2)) + 1;
				const pos = Math.floor(Math.random() * positions.length);

				const p1 = newState[midPhase - 1][pos];
				const p2 = newState[midPhase][pos];
				const p3 = newState[midPhase + 1][pos];

				// Only enforce 2-phase if p2 is isolated (not matching neighbors)
				if (p1 !== p2 && p2 !== p3) {
					const currentIdx = newState[midPhase + 1].indexOf(p2);
					const swapWith = newState[midPhase + 1][pos];

					// Swap to extend p2's stay in the same position
					newState[midPhase + 1][currentIdx] = swapWith;
					newState[midPhase + 1][pos] = p2;
				}

				return newState;
			}


			function getNeighborRandom(state) {
				const newState = JSON.parse(JSON.stringify(state));
				const phase = Math.floor(Math.random() * phases);
				let i = Math.floor(Math.random() * players.length);
				let j = Math.floor(Math.random() * players.length);
				while (j === i) {
					j = Math.floor(Math.random() * players.length);
				}
				if (i === 0 || j === 0) return newState;
				[newState[phase][i], newState[phase][j]] = [newState[phase][j], newState[phase][i]];
				return newState;
			}
			function getNeighborSwitchPlayerPositions(state) {
				const newState = JSON.parse(JSON.stringify(state)); // Deep copy

				// Pick playerA from the full range
				const indexA = Math.floor(Math.random() * players.length);
				const playerA = players[indexA];

				// Determine group: goalies (0-2) or field (3+)
				const groupStart = indexA <= 2 ? 0 : 3;
				const groupEnd = indexA <= 2 ? 3 : players.length;

				// Pick playerB from the same group, excluding playerA
				let indexB;
				do {
					indexB = groupStart + Math.floor(Math.random() * (groupEnd - groupStart));
				} while (indexB === indexA);

				const playerB = players[indexB];

				// Swap their positions in each phase
				for (let phase = 0; phase < newState.length; phase++) {
					const idxA = newState[phase].indexOf(playerA);
					const idxB = newState[phase].indexOf(playerB);

					if (idxA !== -1 && idxB !== -1) {
						[newState[phase][idxA], newState[phase][idxB]] = [newState[phase][idxB], newState[phase][idxA]];
					}
				}

				return newState;
			}



			function getNeighbor(state) {
				const r = Math.random();

				// original:
				// if (r < 0.5) return getNeighborRandom(state);               // player swap in a phase				
				// if (r < 0.8) return getNeighborSwapPositions(state);        // position-role swap
				// return getNeighborEnforce2Phase(state);                     // 2-phase run enforcement

				// perfect 3 phase -> 2 subs 
				if (r < 0.5) return getNeighborSwitchPlayerPositions(state);
				return getNeighborSwapPositions(state);        // position-role swap
			}

			

			function optimizeSchedule(initialState, iterations = 5000, temp = 1000, alpha = 0.98) {
				//updateWeightsFromInputs();
				let current = initialState;
				applyGoalieLocks(current);
				let best = JSON.parse(JSON.stringify(current)) ;
				
				let bestScore = fitness(current) + 0.001;
				let T = temp;

				while (T > 1e-3 && iterations-- > 0) {
					const neighbor = getNeighbor(current);
					applyGoalieLocks(neighbor);
					const delta = fitness(neighbor) - fitness(current);
					if (delta < 0 || Math.random() < Math.exp(-delta / T)) {
						current = neighbor;
						const score = fitness(current);
						if (score < bestScore) {
							best = JSON.parse(JSON.stringify(neighbor));
							bestScore = score;
						}
					}
					T *= alpha;
				}
				
				return best;
			}


			function renderSchedule(schedule) {
				// Clear the relevant containers
				document.getElementById('phaseSchedule').innerHTML = '';

				const phaseColors = Array(phases).fill(null).map(() => Array(positions.length).fill(''));

				for (let i = 0; i < phases - 1; i++) {
					const phase1 = schedule[i];
					const phase2 = schedule[i + 1];

					for (let subIdx = 5; subIdx < positions.length; subIdx++) {
						const sub = phase1[subIdx];
						const subInPhase2Idx = phase2.indexOf(sub);

						if (subInPhase2Idx !== -1 && subInPhase2Idx < 5) {
							phaseColors[i][subIdx] = `swap${subIdx - 4}`; // swap1, swap2, ...
							phaseColors[i][subInPhase2Idx] = `swap${subIdx - 4}`;
						}
					}
				}

				let idHtml = '<h3>Position Grid (Player Numbers)</h3><table><tr><th>Phase</th>' +
					positions.map(p => `<th class="position-header">${p}</th>`).join('') + '</tr>';

				schedule.forEach((phase, i) => {
					idHtml += `<tr><td>${i + 1}</td>`;
					phase.forEach((player, j) => {
						const playerIndex = players.indexOf(player);
						let nextPosClass = '';
						if (i < phases - 1) {
							const nextPhase = schedule[i + 1];
							const nextIndex = nextPhase.indexOf(player);
							const nextPos = positions[nextIndex] || '';
							nextPosClass = 'next-' + (isSubPosition(nextPos) ? 'sub' : nextPos.toLowerCase());
						}
						idHtml += `<td class="${nextPosClass}">${playerIndex + 1}</td>`;
					});
					idHtml += '</tr>';
				});
				idHtml += '</table>';
				document.getElementById('output').innerHTML = idHtml;

				renderPlayerPositionGrid(currentSchedule);
				
				let nameGrid = '<h3>Schedule by Phase</h3><table class="basic-grid"><tr><td>Phase</td>' +
					positions.map((p, i) => {
						const role = isSubPosition(p) ? 'sub' : p.toLowerCase();
						return `<td class="position-header next-${role} clickable" onclick="handleCellClick(this, -1, ${i})">${p}</td>`;
					}).join('') +
					'</tr>';



				schedule.forEach((phase, i) => {
					nameGrid += `<tr><td>${i + 1}</td>`;
					phase.forEach((player, j) => {
						let nextPosClass = '';
						if (i < phases - 1) {
							const nextPhase = schedule[i + 1];
							const nextIndex = nextPhase.indexOf(player);
							const nextPos = positions[nextIndex] || '';
							nextPosClass = 'next-' + (isSubPosition(nextPos) ? 'sub' : nextPos.toLowerCase());
						}
						// nameGrid += `<td class="${nextPosClass}">${player}</td>`;
						nameGrid += `<td class="${nextPosClass}" onclick="handleCellClick(this, ${i}, ${j})">${player}</td>`;

					});
					nameGrid += '</tr>';
				});
				nameGrid += '</table>';
				
				const score = fitness(schedule);
				
				document.getElementById('score').innerHTML = `<p>Score: ${score}</p>`;

				document.getElementById('phaseSchedule').innerHTML = nameGrid;						

				// renderAllPeriods(schedule);
				renderVisualSubView(schedule);

			}

			// window.handleCellClick =  function (cell, phaseIndex, playerIndex) {
			// 	if (!editMode) return;

			// 	if (selectedCell) {
			// 		if (selectedCell.phase === phaseIndex) {
			// 		// swap players
			// 		const tmp = currentSchedule[phaseIndex][selectedCell.index];
			// 		currentSchedule[phaseIndex][selectedCell.index] = currentSchedule[phaseIndex][playerIndex];
			// 		currentSchedule[phaseIndex][playerIndex] = tmp;

			// 		selectedCell = null;
			// 		renderSchedule(currentSchedule); // re-render all
			// 		} else {
			// 		alert("Swap must be within the same phase.");
			// 		selectedCell = null;
			// 		}
			// 	} else {
			// 		selectedCell = { cell, phase: phaseIndex, index: playerIndex };
			// 		cell.style.border = '2px solid red';
			// 	}
			// 	}

			window.handleCellClick = function (cell, phaseIndex, playerIndex) {
				if (!editMode) {
					// Highlight matching player names
					const playerName = cell.textContent.trim();

					// Remove any existing highlights
					document.querySelectorAll('.player-highlight').forEach(el =>
					el.classList.remove('player-highlight')
					);

					// Highlight all matching cells
					document.querySelectorAll('#phaseSchedule td').forEach(td => {
					if (td.textContent.trim() === playerName) {
						td.classList.add('player-highlight');
					}
					});

					return; // Stop here if not in edit mode
				}
				
				
				if (phaseIndex === -1) {
					// Header clicked for column selection
					if (selectedCell && selectedCell.phase === -1) {
						// Second column selected â†’ swap columns
						const col1 = selectedCell.index;
						const col2 = playerIndex;

						for (let i = 0; i < currentSchedule.length; i++) {
							[currentSchedule[i][col1], currentSchedule[i][col2]] =
								[currentSchedule[i][col2], currentSchedule[i][col1]];
						}

						selectedCell.cell.style.border = '';
						selectedCell = null;
						renderSchedule(currentSchedule);
					} else {
						// First column selected
						if (selectedCell) selectedCell.cell.style.border = ''; // clear previous
						selectedCell = { cell, phase: -1, index: playerIndex };
						cell.style.border = '2px solid red';
					}
					return;
				}

				// Regular in-phase cell selection and swap
				if (selectedCell) {
					if (selectedCell.phase === phaseIndex) {
						// swap players
						const tmp = currentSchedule[phaseIndex][selectedCell.index];
						currentSchedule[phaseIndex][selectedCell.index] = currentSchedule[phaseIndex][playerIndex];
						currentSchedule[phaseIndex][playerIndex] = tmp;

						selectedCell.cell.style.border = '';
						selectedCell = null;
						renderSchedule(currentSchedule);
					} else {
						alert("Swap must be within the same phase.");
						selectedCell.cell.style.border = '';
						selectedCell = null;
					}
				} else {
					selectedCell = { cell, phase: phaseIndex, index: playerIndex };
					cell.style.border = '2px solid red';
				}
			};


			window.runSA = function () {

				updatePlayers();
				collectPlayerPreferences();
				currentSchedule = optimizeSchedule(generateInitialState());
				renderSchedule(currentSchedule);
			}


			window.randomizePlayers = function () {
				updatePlayers();

				// Shuffle a copy of current players
				const shuffled = [...players].sort(() => Math.random() - 0.5);

				// Create a mapping from old name to new name
				const mapping = {};
				players.forEach((p, i) => mapping[p] = shuffled[i]);

				// Update playerInput text area with new order
				document.getElementById("playerInput").value = shuffled.join('\n');

				// Apply mapping to current schedule
				if (currentSchedule) {
					currentSchedule = currentSchedule.map(phase =>
						phase.map(p => mapping[p])
					);
					players = shuffled;
					renderSchedule(currentSchedule);
				}
			};

			window.continueOptimize = function () {
				updatePlayers();
				collectPlayerPreferences();
				if (currentSchedule) {
					for (let i = 0; i < 10; i++) {
						currentSchedule = optimizeSchedule(currentSchedule);
					}
					renderSchedule(currentSchedule);
				}
			}
		}
		
		function getSymbolForPosition(pos, size=22) {
			const normalized = pos.startsWith('SUB') ? 'SUB' : pos;			
			let color = positionColors[normalized] || '#000';
			
			// switch (normalized) {
			// 	case 'G':
			// 		return getGlovesIcon(color, size);
			// 	case 'SUB':
			// 		return getSwapIcon(color, size);
			// 	case 'LW':
			// 		return getLeftWingIcon(color, size);
			// 	case 'RW':
			// 		return getRightWingIcon(color, size);
			// 	case 'D':
			// 		return getDefenderIcon(color, size);
			// 	case 'F':
			// 		return getStrikerIcon(color, size);
			// 	default:
			// 		return positionSymbols[normalized] || '';
			// }
			switch (normalized) {
				case 'G':
					color="#777";
				return getGlovesIcon(color, size);
				case 'SUB':
				return getSwapIcon(color, size);
				case 'LW':
				case 'RW':
				case 'D':
				case 'F':
				return getDiamondIcon(normalized, color, size);
				default:
				return positionSymbols[normalized] || '';
			}
		}


		function renderAllPeriods(schedule) {
			// document.getElementById('periodLayout').innerHTML = '';	
			// const container = document.getElementById('periodLayout');

			// document.getElementById("print-area-grid").innerHTML = '';
			// const container = document.getElementById("print-area-grid");

			const totalPeriods = phases / phasesPerPeriod;

			const dividerHeight = phasesPerPeriod === 2 ? '8px' : '0px';
			document.documentElement.style.setProperty('--divider-height', dividerHeight);

			// Create updated layout for dynamic subs
			const layout = [
				['-', 'F', '-', '-', ...(subs.length > 0 ? ['SUB1'] : [])],
				['LW', '-', 'RW', '-', ...(subs.length > 1 ? ['SUB2'] : [])],
				['-', 'D', '-', '-', ...(subs.length > 2 ? ['SUB3'] : [])],
				['-', 'G', '-', '-', ...(subs.length > 3 ? ['SUB4'] : [])]
			];

			// Add more rows if needed
			for (let i = 4; i < Math.ceil(subs.length / 2) + 2; i++) {
				const newRow = ['-', '-', '-', '-', '-', '-'];
				const subIdx = i + 1;
				if (subs[subIdx]) newRow.push(`SUB${subIdx + 1}`);
				layout.push(newRow);
			}

			//let fullHTML = `<h2>Period Layout Grids</h2><div id="print-area"><table class="period-grid">`;
			let fullHTML = `<h2 class="no-print">Period Layout Grids</h2><div id="print-area"><table class="period-grid">`;

			for (let p = 0; p < totalPeriods; p++) {
				const start = p * phasesPerPeriod;
				const end = start + phasesPerPeriod;
				// const label = `Period ${p + 1} (Phases ${start + 1} â†’ ${end})`;
				const label = `Period ${p + 1}`;

				layout.forEach((row, rowIndex) => {
				fullHTML += '<tr>';
				if (rowIndex === 0) {
					fullHTML += `<td class="no-border period-label divider " rowspan="${layout.length}">${label}</td>`;
					fullHTML += `<td class="no-border " rowspan="${layout.length}"></td>`;
				}

				row.forEach(pos => {
					if (pos === '-') {
					fullHTML += `<td class="no-border"></td>`;
					} else {
					const role = isSubPosition(pos) ? 'sub' : pos.toLowerCase();
					fullHTML += `<td class="border-${role} next-${role}">`;

					for (let phase = start; phase < end; phase++) {
						const player = schedule[phase][positions.indexOf(pos)] || '-';

						let nextSymbol = '';
						let nextColor = '#000';
						if (phase < phases - 1 && player !== '-') {
						const nextPhase = schedule[phase + 1];
						const nextIndex = nextPhase.indexOf(player);
						const nextPos = positions[nextIndex] || '';
						const symbolKey = isSubPosition(nextPos) ? 'SUB' : nextPos;

						const color = positionColors[symbolKey] || '#000';
						
						nextSymbol = getSymbolForPosition(symbolKey);
						
						nextColor = positionColors[symbolKey] || '#000';
						}

						const nameStyle = phase === start
						? 'font-weight: 600; color: #111;'
						: 'opacity: 0.85;';

						fullHTML += `
						<div style="display: flex; justify-content: space-between; align-items: center;">
							<span style="${nameStyle}">${player}</span>
							<span class="emoji-symbol" style="color: ${nextColor}">${nextSymbol}</span>
						</div>`;
					}

					fullHTML += `</td>`;
					}
				});
				fullHTML += '</tr>';
				});
				if (p < totalPeriods - 1) {
					fullHTML += `<tr class="period-spacer"><td colspan="${layout[0].length + 2}"></td></tr>
								 <tr class="period-divider"><td colspan="${layout[0].length + 2}"></td></tr>`;
					
				}
			}

			fullHTML += '</table></div>';
			container.insertAdjacentHTML('beforeend', fullHTML);
		}				

		window.toggleView = function () {
			// const grid = document.getElementById("print-area-grid");
			const visual = document.getElementById("print-area-visual");

			const showVisual = grid.style.display !== "none";

			if (showVisual) {
				grid.style.display = "none";
				visual.style.display = "block";
			} else {
				grid.style.display = "block";
				visual.style.display = "none";
			}
		};






function getColorForPosition(pos) {
  const normalized = pos.startsWith('SUB') ? 'SUB' : pos;
  return positionColors[normalized] || '#000';
}
function normalizePos(p) {
  return p.startsWith('SUB') ? 'SUB' : p;
}

function getSubstitutionMarkup(schedule, start, end) {
  const posList = ['G', 'D', 'LW', 'RW', 'F'];
  const subList = positions.filter(p => p.startsWith('SUB'));
  const allKeys = [...posList, ...subList, 'SUB1', 'SUB2', 'INLINE'];
  const rows = Object.fromEntries(allKeys.map(p => [p, '']));
  const goalieIdx = positions.indexOf('G');
 const goalieName = schedule[start][goalieIdx];
const colorMap = {
  '--glove-palm': '#ffffff',
  '--glove-wrist-and-ball': '#9a1f32',
  '--glove-detail': '#9e9798',
  '--contour': '#210e0f'
};

//let rawSvg = getSymbolForPosition('G', 64);
let rawSvg = getSymbolForPosition('G', 64);

// Replace all CSS vars with hex codes
Object.entries(colorMap).forEach(([variable, hex]) => {
  rawSvg = rawSvg.replaceAll(`var(${variable})`, hex);
});
//console.log(rawSvg);
// Now encode and embed
const svgEncoded = encodeURIComponent(rawSvg)
  .replace(/'/g, "%27")
  .replace(/"/g, "%22");

const bgStyle = `
	display: flex;
	align-items: center;
`;


rows['G'] = `
  <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">
    <span class="symbol">${rawSvg}</span>
    <strong>${goalieName}</strong>
  </div>
`;
  // helper to group subs
  function normalizePos(p) {
    return p.startsWith('SUB') ? 'SUB' : p;
  }

  for (let phase = start + 1; phase < end; phase++) {
    const isFirstSwap = phase === start + 1;
    const cssClass    = isFirstSwap ? 'sub1' : 'sub2';
    const borderClass = isFirstSwap ? 'swap1-border' : 'swap2-border';
    const subKey      = isFirstSwap ? 'SUB1' : 'SUB2';

    for (const pos of posList) {
      const idx  = positions.indexOf(pos);
      const prev = schedule[phase - 1][idx];
      const curr = schedule[phase][idx];

      let c_pos = normalizePos(positions.find(p => schedule[phase - 1][positions.indexOf(p)] === curr));
      let p_pos = normalizePos(positions.find(p => schedule[phase][positions.indexOf(p)] === prev));
	  
      if (prev !== curr) { // player exchange on position

		// === Check for clean swap ===
        // let c_pos = normalizePos(positions.find(p => schedule[phase - 1][positions.indexOf(p)] === curr));
        // let p_pos = normalizePos(positions.find(p => schedule[phase][positions.indexOf(p)] === prev));
        let isCleanSwap = c_pos && p_pos && c_pos === p_pos;

		const leaveMarkup = `<span class="${borderClass}" style="color: ${getColorForPosition('SUB')}"><strong>${prev}</strong></span>`;
        const enterMarkup = `<span class="${borderClass}" style="color: ${getColorForPosition('SUB')}"><strong>${curr}</strong></span>`;
		

        
        if (isCleanSwap) {
          // pure swap: show on field A / B
        //   rows[pos] += `<div class="${cssClass}">${leaveMarkup}<span class = "transition"> â‡„ </span> ${enterMarkup}</div>`;
			if(cssClass==='sub1') { //first swap
				rows[pos] += `<div class="starting-player">${prev}</div>`;
				rows[pos] += `<div class="${cssClass} centered" style="text-align: center">${enterMarkup}</div>`;
			}
			if(cssClass==='sub2') { //second swap
				rows[pos] += `<div class="${cssClass} centered" style="text-align: center">${enterMarkup}</div>`;
			}          
		  
          // sub cell: field-symbol then A / B
		  //Substitution column, clean swaps
          const symbol = getSymbolForPosition(pos);
          rows[subKey] +=
            `<div class="${cssClass} sub-line">` +
              `<span class="symbol" >${symbol}</span>&nbsp;` +
              `<span>${enterMarkup} <span class = "transition"> â‡„ </span> ${leaveMarkup}</span>` +
            `</div>`;
        } else {
          // one-way: leave (next-pos-icon) | enter
          // find where 'prev' went
          const targetPos = positions.find(other => schedule[phase][positions.indexOf(other)] === prev);
          const targetSymbol = targetPos ? getSymbolForPosition(targetPos) : '';
		  const symbolKey = isSubPosition(targetPos) ? 'SUB' : targetPos;
		  const targetColor = positionColors[symbolKey] || '#000';
					
		//   rows[pos] +=
        //     `<div class="${cssClass}" style="color: ${targetColor}">` +
        //       `${leaveMarkup} | ${enterMarkup}` +
        //     `</div>`;
		if (rows[pos]==='') {
			rows[pos] +=`<div class="starting-player">${leaveMarkup}</div>`;
		}
		let dot='';
		if(p_pos === 'SUB') {
			dot = 'dot';
		}
		rows[pos] += `<div class="${cssClass} centered ${dot}" style="color: ${targetColor}">` +
			`${enterMarkup}` +
			`</div>`;
		
		//   if (cssClass==='sub2') {
		// 	rows[pos] +=`<div>${leaveMarkup}</div>`;
		// 	rows[pos] += `<div class="${cssClass} centered dot" style="color: ${targetColor}">` +
		// 				`${enterMarkup}` +
		// 		`</div>`;
		//   }
     

          // sub cell one-way: same symbol for field->sub move
		  //Substitution column, non clean swaps
          const symbol = getSymbolForPosition(pos);

		  if (symbolKey === 'SUB') {  // The switching out

				rows[subKey] +=
				`<div class="${cssClass} sub-line">` +
					`<span style="color: ${targetColor}">${leaveMarkup} </span>` +
					`<span class="transition">ðŸ¡²</span>` +
					`<span class="symbol">${targetSymbol}</span>` +
				`</div>`;
				
				
		  } else {
				//The one entering the field
				rows[subKey] +=
				`<div class="${cssClass} sub-line">` +
				`<span class="symbol">${symbol}</span><span class="transition"> ðŸ¡° </span> ${enterMarkup}</span>` +
				`</div>`;

				//The one switching position on the field
				//rows[subKey] +=`<div class="${cssClass} sub-line dot" style="border-style: dotted; border-color: inherit; border-width: 1px;">` +
				rows['INLINE'] +=`<div class="${cssClass} sub-line dot" >` +
				`${leaveMarkup}</span><span class="symbol">${symbol} <span class="transition"> ðŸ¡² </span> ${targetSymbol}</span>` +
				`</div>`;

			}
        }
      } else { // If it's the same player in the same pos
	  	if  (pos != 'G') {
			if (rows[pos] === "") {
				rows[pos] += `<div  class="starting-player">${prev}</div>`;
			}			
		}
      }
    }
  }

  return rows;
}



function renderVisualSubView(schedule) {
	const container = document.getElementById('print-area-visual');
	const matchTitle = document.getElementById('matchTitleInput')?.value || 'Match title';
	container.innerHTML='';

	const header = document.createElement('div');
	header.className = 'visual-header';
	header.innerHTML = `<span>${matchTitle}</span>`;
	container.appendChild(header);

	const totalPeriods = phases / phasesPerPeriod;

	for (let p = 0; p < totalPeriods; p++) {
    const start = p * phasesPerPeriod;
    const end = start + phasesPerPeriod;
    const rows = getSubstitutionMarkup(schedule, start, end);

    const periodDiv = document.createElement('div');
    periodDiv.className = 'visual-period';

    const table = document.createElement('table');
    table.className = 'visual-table';
//   <tr><td colspan="4" class="period-header">Period ${p + 1}</td></tr>
//<td>${getDiamondIcon('ALL','#000', 85)}</td>
    table.innerHTML = `
       
      <tr>
        <td class="visual-cell"><span  style="font-size: 1.3em; font-weight: 600; font-style: italic;">Period ${p + 1}</span></td>
        <td class="visual-cell border-f bg-f">${rows['F']}</td>
        <td></td>
        <td class="visual-cell border-sub bg-sub wide" rowspan="2" ><div><strong>First</strong></div>${rows['SUB1']}</td>
      </tr>
      <tr>
        <td class="visual-cell border-lw bg-lw">${rows['LW']}</td>
        <td></td>
        <td class="visual-cell border-rw bg-rw">${rows['RW']}</td>
      </tr>
      <tr>
        <td></td>
        <td class="visual-cell border-d bg-d">${rows['D']}</td>
        <td class="visual-cell border-sub bg-sub" rowspan="2">${rows['INLINE']}</td>
		<td class="visual-cell border-sub bg-sub wide" rowspan="2" ><div><strong>Second</strong></div>${rows['SUB2']}</td>        
      </tr>
      <tr>
        <td></td>
        <td class="visual-cell border-g bg-g">${rows['G']}</td>        
      </tr>
    `;

    periodDiv.appendChild(table);
    container.appendChild(periodDiv);
  }
}




		function renderPlayerPositionGrid(state) {
			const grid = getPlayerPositionGrid(state);
			const positions = [...basePositions, 'SUB'];

			let html = '<h3>Player Position Counts</h3><table class="basic-grid" border="1" cellpadding="5" cellspacing="0"><tr><th>Player</th>';
			
			for (const pos of positions) {
				html += `<th>${pos}</th>`;
			}
			html += '</tr>';

			for (const player of players) {
				html += `<tr><td>${player}</td>`;
				for (const pos of positions) {
					html += `<td>${grid[player][pos]}</td>`;
				}
				html += '</tr>';
			}

			html += '</table>';

			document.getElementById('output').innerHTML = html;
			document.getElementById('output').style.display = 'block';
		}

		function getPlayerPositionGrid(state) {
			const grid = {};
			const allPositions = [...basePositions, 'SUB'];
			// console.log(allPositions);
			// Initialize empty grid
			for (const player of players) {
				grid[player] = {};
				for (const pos of allPositions) {
					grid[player][pos] = 0;
				}
			}
			
			// Fill counts
			for (let phase = 0; phase < phases; phase++) {
				for (let pos = 0; pos < positions.length; pos++) {
					const player = state[phase][pos];
					const positionName = isSubPosition(positions[pos]) ? 'SUB' : positions[pos];
					try {
						grid[player][positionName]++;
					}
					catch {
						console.log('failed player:', player);
						console.log('failed position:', positionName);
					}
				}
			}

			return grid;
		}

		document.addEventListener('click', function (e) {
		if (!e.target.closest('#phaseSchedule td')) {
			document.querySelectorAll('.player-highlight').forEach(el =>
			el.classList.remove('player-highlight')
			);
		}
		});

	</script>
</body>

</html>