<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SA Roster Scheduler</title>
  <style>
    table.period-grid {
      margin: 20px 0;
      border: 2px solid #888;
      box-shadow: 2px 2px 8px rgba(0,0,0,0.1);
      border-radius: 6px;
      overflow: hidden;
    }
    table.period-grid td {
      padding: 10px;
      min-width: 60px;
      /* background-color: #f9f9f9; */
    }
    table.period-grid h3 {
      margin-top: 30px;
      font-size: 1.1em;
      color: #333;
    }
    body { font-family: Arial, sans-serif; padding: 20px; }
    table { border-collapse: collapse; margin-top: 20px; }
    td, th { border: 1px solid #ccc; padding: 5px 10px; text-align: center; }
    .swap1 { background-color: #ffeeba; }
    .swap2 { background-color: #bee5eb; }
    .swap3 { background-color: #d4edda; }
    .goalieswap { background-color: #f5c6cb; }

    td.next-g    { background-color: #fddde6; }
    td.next-d    { background-color: #d6eaff; }
    td.next-lw   { background-color: #ffe9cc; }
    td.next-rw   { background-color: #e4fcd4; }
    td.next-f    { background-color: #e0d6f5; }
    td.next-sub  { background-color: #f0f0f0; }

    .border-g   { border: 3px solid #f58aa3; }
    .border-d   { border: 3px solid #8ac3ff; }
    .border-lw  { border: 3px solid #ffc98b; }
    .border-rw  { border: 3px solid #a9e88f; }
    .border-f   { border: 3px solid #b6a4e3; }
    .border-sub { border: 3px solid #ccc; }


    th.position-header {
      background-color: #f8f9fa;
      font-weight: bold;
    }

  </style>
</head>
<body>
  <h1>Simulated Annealing Roster Scheduler</h1>
  <label for="playerInput">Player Names (One name per row):</label><br>
  <textarea id="playerInput" rows="7" cols="60" oninput="updatePlayers()">Alice
Bob
Charlie
Diana
Eve
Frank
Grace</textarea><br>

	<label for="phasesPerPeriod">Substitution opportunities per period:</label>
	<select id="phasesPerPeriod" onchange="updatePhases()">
	  <option value="2" selected>1 (2 phases)</option>
	  <option value="3">2 (3 phases)</option>
	</select>

  <br><br>
  <button onclick="runSA()">Generate Schedule</button>
  <button onclick="continueOptimize()">Continue Optimize</button>
  <button onclick="randomizePlayers()">Randomize Players</button>
  <div id="output" style="display: none;"></div>
  <div id="score"></div>
  <div id="namedGrid"></div>

  <script>
  
	let players = [];
  const basePositions = ['G', 'D', 'LW', 'RW', 'F'];
  let nrSubs = 0;
  let subs = [];
  let positions = [];
  
	let phasesPerPeriod = 2;
	let phases = phasesPerPeriod * 3;
	let currentSchedule = null;
	
  function isSubPosition(pos) {
    return pos.startsWith("SUB");
  }

    window.onload = function() {
   

		window.updatePhases = function() {
		  phasesPerPeriod = parseInt(document.getElementById("phasesPerPeriod").value, 10);
		  phases = phasesPerPeriod * 3;
		  console.log('Phases updated to:', phases);
		}
		
		
      window.updatePlayers = function () {
        const input = document.getElementById("playerInput").value;
        players = input.split(/[\n,]+/).map(p => p.trim()).filter(p => p);

        nrSubs = players.length - 5;
        subs = Array.from({ length: nrSubs }, (_, i) => `SUB${i + 1}`);
        positions = basePositions.concat(subs);
      };

      function generateInitialState() {
        const state = [];
        for (let i = 0; i < phases; i++) {
          const phasePlayers = [...players].sort(() => Math.random() - 0.5);
          state.push(phasePlayers);
        }
        return state;
      }

	function applyGoalieLocks(state) {
	  <!-- const phasesPerPeriod = subsPerPeriod; // e.g., 2 subs → 3 phases -->
	  for (let phase = 0; phase < state.length; phase++) {
		const periodIndex = Math.floor(phase / phasesPerPeriod);
		const goalie = players[periodIndex % 3]; // Cycle through first 3 goalies
		const filtered = state[phase].filter(p => p !== goalie);
		state[phase] = [goalie, ...filtered];
	  }
	}


function fitness(state) {
  const playCounts = {};
  const posHistory = {};
  let penalty = 0;

  // Count how many subs are used based on total players
  const nrSubs = players.length - 5;  // 5 field positions
  const targetPlaytime = (phases * 4) / (4 + nrSubs); // Expected time per non-goalie
  const phasesPerPeriod = phases / 3;
  const goaliePhaseTime = Math.floor(targetPlaytime / 3) / phasesPerPeriod;

  // Init tracking
  for (const p of players) {
    playCounts[p] = 0;
    posHistory[p] = [];
  }

  // Phase loop: accumulate playCounts and position history
  for (let phase = 0; phase < phases; phase++) {
    const currentPlayers = [];

    for (let pos = 0; pos < positions.length; pos++) {
      const player = state[phase][pos];
      const isSub = isSubPosition(positions[pos]);

      if (!isSub) {
        if (pos === 0) {
          // Rule: goalie only gets partial credit per phase
          playCounts[player] += goaliePhaseTime;
        } else {
          playCounts[player] += 1;
        }
      }

      posHistory[player].push(positions[pos]);
      currentPlayers.push(player);
    }

    if (phase > 0) {
      const prev = state[phase - 1];
      const curr = state[phase];
      let stableCount = 0;
      const goalieChanged = prev[0] !== curr[0]; // goalie is index 0

      // Rule 1: Penalize instability if goalie hasn’t changed
      for (let i = 1; i <= 4; i++) {
        if (prev[i] === curr[i]) stableCount++;
      }

      if (stableCount < 2 && !goalieChanged) {
        penalty += (2 - stableCount) * 20;
      }

      // Rule 2: Penalize deviation from 2 substitutions per phase
      const prevPlayers = new Set(prev);
      const currPlayers = new Set(curr);
      let changes = 0;
      for (const p of currPlayers) {
        if (!prevPlayers.has(p)) changes++;
      }
      const subCount = changes / 2;
      penalty += Math.pow(subCount - 2, 2);
    }
  }

  // Player loop: apply penalties and rewards
  for (const p of players) {
    const history = posHistory[p];
    const subs = history.filter(isSubPosition).length;

    // Rule 4: Penalize consecutive SUBs
    for (let i = 1; i < history.length; i++) {
      if (isSubPosition(history[i]) && isSubPosition(history[i - 1])) {
        penalty += 10;
      }
    }

    // Rule 6: Penalize 3+ consecutive same position
    let runLength = 1;
    for (let i = 1; i < history.length; i++) {
      if (history[i] === history[i - 1]) {
        runLength++;
        if (runLength >= 3) penalty += 5;
      } else {
        runLength = 1;
      }
    }

    // Rule 7: Goalies - discourage >1 sub (low priority for now)
    if (isGoalie(p) && subs > 1) {
      // Currently zero penalty (disabled logic)
      // penalty += Math.pow(subs - 1, 2) * 5;
    }

    // Rule 5: Fair playtime for all players
    const time = playCounts[p];
    const dist = time - targetPlaytime;
    penalty += 4 * dist * dist;

    // Rule 8: Reward position variety
    const uniqueCount = new Set(history.filter(h => !isSubPosition(h))).size;
    penalty -= uniqueCount * 1.5;

    // Rule 9: Encourage 2-phase consistency
    for (let i = 1; i < history.length; i++) {
      const prev = history[i - 1];
      const curr = history[i];
      if (!isSubPosition(prev) && !isSubPosition(curr)) {
        if (curr === prev) penalty -= 1;
        else penalty += 2;
      }
    }
  }

  return penalty;
}

// Helpers
function isSubPosition(pos) {
  return pos.startsWith("SUB");
}

function isGoalie(player) {
  return player === players[0] || player === players[1] || player === players[2];
}



		function averageNonGoaliePlaytime() {
		  const nonGoalies = players.filter(p => !isGoalie(p));
		  return (phases * (positions.length - 3)) / nonGoalies.length; // 3 goalie positions assumed
		}


      function getNeighbor(state) {
        const newState = JSON.parse(JSON.stringify(state));
        const phase = Math.floor(Math.random() * phases);
        let i = Math.floor(Math.random() * players.length);
        let j = Math.floor(Math.random() * players.length);
        if (i === 0 || j === 0) return newState;
        [newState[phase][i], newState[phase][j]] = [newState[phase][j], newState[phase][i]];
        return newState;
      }

      function optimizeSchedule(initialState, iterations = 5000, temp = 1000, alpha = 0.98) {
        let current = initialState;
        applyGoalieLocks(current);
        let best = JSON.parse(JSON.stringify(current));
        let bestScore = fitness(current);
        let T = temp;
        while (T > 1e-3 && iterations-- > 0) {
          const neighbor = getNeighbor(current);
          applyGoalieLocks(neighbor);
          const delta = fitness(neighbor) - fitness(current);
          if (delta < 0 || Math.random() < Math.exp(-delta / T)) {
            current = neighbor;
            const score = fitness(current);
            if (score < bestScore) {
              best = JSON.parse(JSON.stringify(neighbor));
              bestScore = score;
            }
          }
          T *= alpha;
        }
        return best;
      }

      function renderSchedule(schedule) {
        document.getElementById('namedGrid').innerHTML = ''; // clear before adding new content

        const phaseColors = Array(phases).fill(null).map(() => Array(positions.length).fill(''));

        for (let i = 0; i < phases - 1; i++) {
          const phase1 = schedule[i];
          const phase2 = schedule[i + 1];

          for (let subIdx = 5; subIdx < positions.length; subIdx++) {
            const sub = phase1[subIdx];
            const subInPhase2Idx = phase2.indexOf(sub);

            if (subInPhase2Idx !== -1 && subInPhase2Idx < 5) {
              phaseColors[i][subIdx] = `swap${subIdx - 4}`; // swap1, swap2, ...
              phaseColors[i][subInPhase2Idx] = `swap${subIdx - 4}`;
            }
          }
        }
       
        let idHtml = '<h3>Position Grid (Player Numbers)</h3><table><tr><th>Phase</th>' +
          positions.map(p => `<th class="position-header">${p}</th>`).join('') + '</tr>';

        schedule.forEach((phase, i) => {
          idHtml += `<tr><td>${i + 1}</td>`;
          phase.forEach((player, j) => {
            const playerIndex = players.indexOf(player);
            let nextPosClass = '';
            if (i < phases - 1) {
              const nextPhase = schedule[i + 1];
              const nextIndex = nextPhase.indexOf(player);
              const nextPos = positions[nextIndex] || '';
              nextPosClass = 'next-' + (isSubPosition(nextPos) ? 'sub' : nextPos.toLowerCase());
            }
            idHtml += `<td class="${nextPosClass}">${playerIndex + 1}</td>`;
          });
          idHtml += '</tr>';
        });
        idHtml += '</table>';
        document.getElementById('output').innerHTML = idHtml;

        let nameGrid = '<h3>Schedule by Phase</h3><table><tr><th>Phase</th>' +
          positions.map(p => `<th class="position-header">${p}</th>`).join('') + '</tr>';

        schedule.forEach((phase, i) => {
          nameGrid += `<tr><td>${i + 1}</td>`;
          phase.forEach((player, j) => {
            let nextPosClass = '';
            if (i < phases - 1) {
              const nextPhase = schedule[i + 1];
              const nextIndex = nextPhase.indexOf(player);
              const nextPos = positions[nextIndex] || '';
              nextPosClass = 'next-' + (isSubPosition(nextPos) ? 'sub' : nextPos.toLowerCase());
            }
            nameGrid += `<td class="${nextPosClass}">${player}</td>`;
          });
          nameGrid += '</tr>';
        });
        nameGrid += '</table>';
        document.getElementById('namedGrid').innerHTML = nameGrid;

        const score = fitness(schedule);
        document.getElementById('score').innerHTML = `<p>Score: ${score}</p>`;

        renderAllPeriods(schedule);

      }


      window.runSA = function() {
        updatePlayers();
        currentSchedule = optimizeSchedule(generateInitialState());
        renderSchedule(currentSchedule);
      }


		window.randomizePlayers = function() {
		  updatePlayers();

		  // Shuffle a copy of current players
		  const shuffled = [...players].sort(() => Math.random() - 0.5);

		  // Create a mapping from old name to new name
		  const mapping = {};
		  players.forEach((p, i) => mapping[p] = shuffled[i]);

		  // Update playerInput text area with new order
		  document.getElementById("playerInput").value = shuffled.join('\n');

		  // Apply mapping to current schedule
		  if (currentSchedule) {
			currentSchedule = currentSchedule.map(phase =>
			  phase.map(p => mapping[p])
			);
			players = shuffled;
			renderSchedule(currentSchedule);
		  }
		};

      window.continueOptimize = function() {
        updatePlayers();
        if (currentSchedule) {
			for (let i = 0; i <100; i++) {
			  currentSchedule = optimizeSchedule(currentSchedule);
			}
			renderSchedule(currentSchedule);
        }
      }
    }

	function renderAllPeriods(schedule) {
  const container = document.getElementById('namedGrid');
  const totalPeriods = phases / phasesPerPeriod;

  // Create updated layout for dynamic subs
  const layout = [
    ['-', 'F', '-', '-', '-', ...(subs.length > 0 ? ['SUB1'] : [])],
    ['LW', '-', 'RW', '-', '-', ...(subs.length > 1 ? ['SUB2'] : [])],
    ['-', 'D', '-', '-', '-', ...(subs.length > 2 ? ['SUB3'] : [])],
    ['-', 'G', '-', '-', '-', ...(subs.length > 3 ? ['SUB4'] : [])]
  ];

  // Add more rows if needed
  for (let i = 4; i < Math.ceil(subs.length / 2) + 2; i++) {
    const newRow = ['-', '-', '-', '-', '-', '-'];
    const subIdx = i + 1;
    if (subs[subIdx]) newRow.push(`SUB${subIdx + 1}`);
    layout.push(newRow);
  }

  container.innerHTML += `<h2>Period Layout Grids</h2>`;

  for (let p = 0; p < totalPeriods; p++) {
    const start = p * phasesPerPeriod;
    const end = start + phasesPerPeriod;
    const label = `Period ${p + 1} (Phases ${start + 1} → ${end})`;

    let html = `<h3>${label}</h3><table class="period-grid">`;

    layout.forEach(row => {
      html += '<tr>';
      row.forEach(pos => {
        if (pos === '-') {
          html += `<td>-</td>`;
        } else {
          const role = isSubPosition(pos) ? 'sub' : pos.toLowerCase();
          html += `<td class="border-${role} next-${role}">`;
          for (let phase = start; phase < end; phase++) {
            const player = schedule[phase][positions.indexOf(pos)] || '-';
            html += `<div>${player}</div>`;
          }
          html += `</td>`;

        }
      });
      html += '</tr>';
    });

    html += '</table>';
    container.insertAdjacentHTML('beforeend', html);
  }
}


</script>
</body>
</html>
